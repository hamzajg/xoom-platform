import groovy.json.*
import groovy.xml.XmlUtil

plugins {
  id 'org.ajoberstar.grgit' version '1.7.2'
}

ext.githubUri = 'https://github.com/vlingo/'
ext.checkoutDir = projectDir.parent

// this is the central desired version configuration for the vlingo platform
ext.repos = [
                    'vlingo-platform': [version: '1.1.0', skip_checkout: true], // special case: this repository
                      'vlingo-common': [version: '1.1.0'],
                      'vlingo-actors': [version: '1.1.0'],
                     'vlingo-streams': [version: '1.1.0'],
                 'vlingo-streams-tck': [version: '1.1.0'],
                        'vlingo-wire': [version: '1.1.0'],
                     'vlingo-cluster': [version: '1.1.0'],
                   'vlingo-directory': [version: '1.1.0'],
                        'vlingo-http': [version: '1.1.0'],
                        'vlingo-auth': [version: '1.1.0'],
                      'vlingo-symbio': [version: '1.1.0'],
             'vlingo-symbio-dynamodb': [version: '1.1.0'],
                'vlingo-symbio-geode': [version: '1.1.0'],
                 'vlingo-symbio-jdbc': [version: '1.1.0'],
                     'vlingo-lattice': [version: '1.1.0'],
      'vlingo-lattice-exchange-camel': [version: '1.1.0'],
   'vlingo-lattice-exchange-rabbitmq': [version: '1.1.0'],
                    'vlingo-schemata': [version: '1.1.0'],
                   'vlingo-telemetry': [version: '1.1.0'],
//                      'vlingo-xoom': [version: '1.1.0'],
               'vlingo-build-plugins': [version: '1.1.0'],
          'vlingo-build-plugins-test': [version: '1.1.0'],
                    'vlingo-examples': [version: '1.1.0'],
]

// simple run gradle or ./gradlew
defaultTasks 'sync'


// first do this
task checkout {
  description 'checkout or update all vlingo repositories (commit changes to the repos beforehand)'

    repos
      .findAll { _repo, config -> ! config.skip_checkout }
      .each { repo, _config ->
        cloneOrPull repo
      }
}

// then that
task syncVersions {
  description 'synchronizes the repos and their dependency versions'

  doLast {
    withSubprojects(repos).each { repo, config ->
      replaceVersionInTextFor repo, config
      syncPomVersionsFor repo, config, repos
    }
  }
}

// default umbrella task
task sync(dependsOn: [
  checkout,
  syncVersions,
]) {
  description 'perform all maintenance actions at once'
}

// when releasing:
//
// ISSUE: Currently no way to get credentials passed correctly to open()
// so don't push. Use the following from the root of the repositories.
//
//
// #!/bin/bash
// find . -maxdepth 1 -mindepth 1 -name "vlingo-*" | sort | while read f
// do
//     echo "---------------------------------"
//     echo $f
//     echo "---------------------------------"
//     cd $f
//     git push 2>/dev/null
//     echo ""
//     cd ..
// 
// Note: The skip_checkout is used because vlingo-platform should be
// release separately (and in last order).
//
task pushRelease {
  description 'add, commit, and push all listed vlingo repositories with current version'

  repos
  .findAll { candidateRepo, candidateConfig -> ! candidateConfig.skip_checkout }
  .each { repo, config ->
    println "Releasing $repo as $config.version"
    
    def dir = "$checkoutDir/$repo"
    def commitMessage = "Update to version $config.version"
    
    grgit = org.ajoberstar.grgit.Grgit.open(dir: dir)
    grgit.add(patterns: ["README.md", "bintray.json", "pom.xml"])
    grgit.commit(message: commitMessage)
    // grgit.push()
    grgit.close()
  }
}

def cloneOrPull(repo) {
      def grgit

      def dir = "$checkoutDir/$repo"
      def uri = "$githubUri$repo"

      if (!file(dir).exists()) {
        println "Cloning $uri into $dir"
        grgit = org.ajoberstar.grgit.Grgit.clone(dir: dir, uri: uri)
      } else {
        println "Pulling $uri into $dir"
        grgit = org.ajoberstar.grgit.Grgit.open(dir: dir)
        grgit.pull()
      }

      def lastCommit = new JsonBuilder(grgit.log(maxCommits: 1).last()).toPrettyString()
      println "Last commit: $lastCommit"

}

def withSubprojects(repos) {
  def moreRepos = repos
  repos.each { repoName, repo ->
    def subfoldersWithPom = []
    // todo: functional instead of loops
    file("$checkoutDir/${repoName}")
      .eachDirRecurse { subfolder ->
        if (validRepo(subfolder)) {
          def subproject = file(checkoutDir).relativePath(subfolder)
          repos[subproject] = [version: repo.version]
          println "Found a subproject: ${subproject}"
        }
      }
  }
  return moreRepos
}

def validRepo(dir) {
  return !dir.path.contains('.git') &&
    new File(dir, "pom.xml").exists()
}

def replaceVersionInTextFor(repo, config) {
  def dir = "$checkoutDir/$repo"
  def replacementSets = [
    [name: 'README.md', versionRegex: /(<version>)(\S+)(<\/version>)/, replacement: "\\1${config.version}\\3"],
    [name: 'README.md', versionRegex: /(compile.*\:)(\S+)(\')/, replacement: "\\1${config.version}\\3"],
    [name: 'bintray.json', versionRegex: /(\s*\"version\":\s*\{\s*\"name\"\s*\:\s*\")(\S+)(\")/, replacement: "\\1${config.version}\\3"],
    [name: 'bintray.json', versionRegex: /(${repo}\/)(\S+)(\/)/, replacement: "\\1${config.version}\\3"],
    [name: 'bintray.json', versionRegex: /(${repo}-)(\S+)(\.)/, replacement: "\\1${config.version}\\3"],
  ]

  replacementSets.each { repl ->
    def path = "$dir/$repl.name"
    println "Syncing $path to $config.version. Regex: ${repl.versionRegex}"

    // simple regex replacements
    ant.replaceregexp(
      match: repl.versionRegex,
      replace: repl.replacement,
      encoding: 'UTF-8',
      flags: 'g') {
        fileset(dir: dir) {
            include(name: repl.name)
        }
    }
  }
}

def syncPomVersionsFor(repo, config, repos) {
  def pom = "$checkoutDir/${repo}/pom.xml"
  def xml = file(pom).text
  def root = new XmlParser().parseText(xml)
 
  // sync the library version
  root.version[0].value = config.version

  // sync the dependencies versions
  repos.each { name, dependency ->
    root.dependencies.dependency
      .findAll { it.artifactId.text() == name }
      .each {
        def oldVersion = it.version[0].text()
        def newVersion = dependency.version
        if( oldVersion != newVersion ) {
          println "changing dependency ${it.artifactId.text()}: ${oldVersion} -> ${newVersion}"
          it.version[0].value = newVersion
        }
      }
  }
 
  def writer = new XmlNodePrinter(new PrintWriter(file(pom)))
  writer.preserveWhitespace = true
  writer.print(root)
}